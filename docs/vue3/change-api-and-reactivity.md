# API和数据响应式的变化

## 为什么去掉了 Vue 构造函数?

在过去，如果页面上遇到一个页面创建多个 `Vue` 实例时可能会出现一些问题.

当对一个实例进行 Vue.use()、Vue.mixin()、Vue.component() 配置时，影响的将时所有的Vue实例。

在 `Vue3` 中，去掉了`Vue构造函数`，转而使用 `createApp` 函数来创建应用实例，把全局操作放到了 `Vue实例` 中，这样可以使实例之间互不影响。

整理后的回答：

> 1.调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同应用

> 2.vue2的构造函数继承太多功能了，不利于tree shaking，vue3把这些功能用普通函数到处，能够充分tree shaking优化打包体积

> 3.vue2没有把组件实例和vue应用两个概念区分开，在vue2中，通过new Vue创建对象，即是一个vue应用，同时又是一个特殊的vue组件。在vue3中，把两个概念区分开来，通过createApp创建的对象，是一个vue应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件

## Vue3 响应式

`Vue3` 不再使用 `Object.defineProperty` 的方式定义完成数据响应式，而是使用 `Proxy`。

除了 `Proxy` 本身效率比 `Object.defineProperty` 更高之外，由于不必递归所有属性，而是直接得到一个 `Proxy`。所以在 `Vue3` 中，对数据的访问是同台的，当访问某个属性的时候，再动态的获取和设置，这就极大的提升了在组建初始阶段的效率。

同时，由于 `Proxy` 可以监控到成员的新增和删除，因此，在 `Vue3` 中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在 `Vue2` 中是难以做到的。