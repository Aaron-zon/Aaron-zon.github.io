import{_ as i,c as a,a0 as n,o as t}from"./chunks/framework.UCJAoCzn.js";const g=JSON.parse('{"title":"JavaScript 事件循环","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"js/js-event-loop.md","filePath":"js/js-event-loop.md"}'),l={name:"js/js-event-loop.md"};function p(e,s,h,k,r,o){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="javascript-事件循环" tabindex="-1">JavaScript 事件循环 <a class="header-anchor" href="#javascript-事件循环" aria-label="Permalink to &quot;JavaScript 事件循环&quot;">​</a></h1><p>事件循环（Event Loop）是 JavaScript 处理异步任务的核心机制，它负责协调 <strong>同步代码、异步回调、微任务、宏任务</strong> 的执行顺序。</p><p>确保 JavaScript 在单线程环境下仍能搞笑的处理异步操作，如 <strong>定时器、AJAX、Promise、事件监听</strong> 等。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>JavaScript 是单线程的。它所能进行异步操作依赖于浏览器的其他线程，与其本身并无直接关系。</p><p>栗子：</p><p>当进行AJAX操作时，JS 会将它交给浏览器的 AJAX线程，在执行结束后，回调函数会被放入 <strong>任务队列</strong> 中，待JS线程空闲时，再从队列中取出回调函数并执行。</p></div><h2 id="模型涉及的容器" tabindex="-1">模型涉及的容器 <a class="header-anchor" href="#模型涉及的容器" aria-label="Permalink to &quot;模型涉及的容器&quot;">​</a></h2><ul><li>源代码：存放源函数；</li><li>调用栈：取得函数，在此处进行执行；</li><li>异步线程（Ajax线程、定时器线程等）：存放异步操作，结束后会将回调放入任务队列中；</li><li>任务队列：用于存放异步任务的回调，分为 <strong>微任务队列</strong> 和 <strong>宏任务队列</strong><ul><li>微任务队列：只有一个，存放微任务 <ul><li>promise.then()、promise.catch()</li><li>new MutaionObserver()</li><li>process.nextTick()</li></ul></li><li>宏任务队列：可能存在多个，存放宏任务，如 setTimeout、setInterval、DOM 事件等； <ul><li>setTimeout()</li><li>setInterval()</li><li>setImmediate()</li></ul></li></ul></li><li>事件循环：不断检查调用栈是否为空，如果为空，就会执行任务队列中的任务（优先执行微任务）；</li></ul><h2 id="事件循环执行顺序" tabindex="-1">事件循环执行顺序 <a class="header-anchor" href="#事件循环执行顺序" aria-label="Permalink to &quot;事件循环执行顺序&quot;">​</a></h2><p>1.从 <strong>源代码</strong> 中拿取函数，如果是 <strong>同步函数</strong> ，直接执行，如果是 <strong>异步函数</strong> 则放入对应的异步线程中；</p><p>2.在调用栈中执行同步代码，执行完成后出栈；</p><p>3.异步函数执行结束后将回调放入任务队列中，任务队列分为 <strong>微任务队列</strong> 和 <strong>宏任务队列</strong>；</p><p>4.循环检查如果调用栈为空，则从 <strong>任务队列</strong> 中取出任务，放入 <strong>调用栈</strong> 中执行，遵循 <strong>微任务优先</strong> 的原则</p><h2 id="举个栗子" tabindex="-1">举个栗子 <a class="header-anchor" href="#举个栗子" aria-label="Permalink to &quot;举个栗子&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;同步代码1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;同步代码2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;同步代码3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行结果：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步代码1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步代码2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 同步代码3</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// promise</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// setTimeout</span></span></code></pre></div><p><strong>执行结果分析</strong></p><p>在代码中由 <strong>同步代码</strong> 和 <strong>异步代码</strong> 组成。</p><p>其中 <code>setTimeout()</code> 在执行结束后会被放入 <strong>宏队列</strong>，而 <code>Promise.resolve().then()</code> 会被放入 <strong>微任务队列</strong> 中。</p><p>在执行时，首先执行 <strong>同步代码</strong>，因此最先输出：同步代码1、同步代码2、同步代码3。</p><p>同步代码执行结束后，调用栈清空，这时会从任务队列中拿取函数，因为优先拿取 <strong>微任务</strong>，因此输出：promise</p><p>调用栈再次清空后，再次从 <strong>任务队列</strong> 中拿取函数，此时没有 <strong>微任务</strong>，因此拿去 <strong>宏任务</strong>，输出：setTimeout</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>事件循环负责调度 同步任务、微任务和宏任务的执行顺序。</li><li>同步代码限制性，微任务优先于宏任务。</li><li><code>async/await</code> 是 <code>Promise</code> 的语法糖，<code>await</code> 后代码会进入微任务。</li></ul>`,21)]))}const d=i(l,[["render",p]]);export{g as __pageData,d as default};
