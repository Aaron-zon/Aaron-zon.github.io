import{_ as a,c as i,a0 as n,o as e}from"./chunks/framework.UCJAoCzn.js";const o=JSON.parse('{"title":"响应式原理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"vue3/reactive-principle.md","filePath":"vue3/reactive-principle.md"}'),p={name:"vue3/reactive-principle.md"};function l(t,s,h,k,d,r){return e(),i("div",null,s[0]||(s[0]=[n(`<h1 id="响应式原理" tabindex="-1">响应式原理 <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理&quot;">​</a></h1><p>Vue2 和 Vue3 使用了不同的方式进行响应式处理。</p><ul><li>Vue2 的响应式是基于 <code>Object.defineProperty</code> 实现的</li><li>Vue3 的响应式是基于ES6的 <code>Proxy</code> 实现的</li></ul><p>它们都是通过拦截数据的读取和设置来实现视图自动更新。</p><h2 id="vue2-的响应式原理" tabindex="-1">Vue2 的响应式原理 <a class="header-anchor" href="#vue2-的响应式原理" aria-label="Permalink to &quot;Vue2 的响应式原理&quot;">​</a></h2><p>Vue2 利用 <code>Object.defineProperty</code> 对对象的每个属性进行劫持，它提供了 <code>getter</code> 和 <code>setter</code> 两个方法可以分别用于拦截数据的读取和赋值，从而在数据变化的同时通知依赖（如组件视图）更新。</p><h3 id="依赖收集" tabindex="-1">依赖收集 <a class="header-anchor" href="#依赖收集" aria-label="Permalink to &quot;依赖收集&quot;">​</a></h3><p>在初始化时，每个响应式属性会维护一个“依赖列表”。</p><p>类似以下结构（当然会复杂的多）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const dep = {</span></span>
<span class="line"><span>    name: [</span></span>
<span class="line"><span>        &#39;&lt;span&gt;用户名：{{ name }}&lt;/spam&gt;&#39;,</span></span>
<span class="line"><span>        &#39;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&#39;</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这样当 <code>Object.defineProperty</code> 监听到数据变化时，就可以快速的得到该属性依赖的Dom。</p><p>如下述代码中，name被更改后通过 dep[&#39;name&#39;] 就可以找到name所依赖的 DOM，这时只要对这部分的 DOM 更新就可以了。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;小明&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;&lt;span&gt;用户名：{{ name }}&lt;/spam&gt;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        &#39;&lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newValue) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// data.name 属性被修改时触发</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通过 dep[&#39;name&#39;] 可以获取 data.name 所依赖的 Dom</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通过 newValue 可以知道被修改的值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 这样就可以对 Dom 进行修改了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这个响应的过程全程都是 Vue 自动完成的，这使得我们在复杂项目中，可以将关注点放在业务逻辑的处理中，而不是修改视图。</p><h3 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;局限性&quot;">​</a></h3><p><code>Object.defineProperty</code> 也并非是完美的，它又两个大问题。</p><ul><li><p>1.新增和删除对象属性无法被监听到。</p><ul><li>这里 Vue 提供了 Vue.set 和 delete 来解决这个问题，虽然可以解决，但也让我们需要分出一部分精力来关注对象属性是否存在无法监听的情况。</li></ul></li><li><p>2.对数组内的操作同样无法完美的处理，操作数组内部的值无法被 <code>Object.defineProperty</code> 拦截。</p><ul><li>这里 Vue 通过原型重写了数组的 push、pop、splice 等方法，保证当使用这些方法操作数组时可以被正常监听。但是数组的操作十分灵活，如果直接使用索引来添加数组值则无法被监听。</li></ul></li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arr: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可以触发响应式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [1, 2, 3, 4]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无法触发响应式</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.arr[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre></div><p>此外还有一些细节问题，比如 <code>Object.defineProperty</code> 只能对对象本身进行监听，不能对对象内的属性进行监听。因此 Vue2 使用 <code>Object.defineProperty</code> 的同时还进行了 <strong>递归处理</strong> ，为每一个需要监听的属性递归调用 <code>Object.defineProperty</code> 。</p><h2 id="vue3-的响应式原理" tabindex="-1">Vue3 的响应式原理 <a class="header-anchor" href="#vue3-的响应式原理" aria-label="Permalink to &quot;Vue3 的响应式原理&quot;">​</a></h2><p>Vue3 使用了 ES6 的 <code>Proxy</code> 对象来处理响应式。</p><p>它可以全面拦截对象的所有操作，从而实现更细粒度和全面的响应式能力</p><h3 id="相比于-vue2-的优势" tabindex="-1">相比于 vue2 的优势 <a class="header-anchor" href="#相比于-vue2-的优势" aria-label="Permalink to &quot;相比于 vue2 的优势&quot;">​</a></h3><ul><li>全面性：能够监听对象的新增和删除，解决了 Vue2 中数组的一些限制。</li><li>性能提升：拦截更高效，可以对对象内所有属性进行拦截，不必再进行递归调用。</li><li>更灵活：允许拦截更多操作，支持更多语言特性和边缘场景</li></ul>`,24)]))}const E=a(p,[["render",l]]);export{o as __pageData,E as default};
