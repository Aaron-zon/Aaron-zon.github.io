import{_ as c,c as o,a0 as a,o as d}from"./chunks/framework.P9qPzDnn.js";const t="/assets/change-webpack.rbFzJFJS.png",p="/assets/change-vite.cXv0BNx3.png",u=JSON.parse('{"title":"从 Webpack 到 Vite","description":"","frontmatter":{},"headers":[],"relativePath":"vue3/change-webpack-to-vite.md","filePath":"vue3/change-webpack-to-vite.md"}'),i={name:"vue3/change-webpack-to-vite.md"};function r(l,e,n,s,b,k){return d(),o("div",null,e[0]||(e[0]=[a('<h1 id="从-webpack-到-vite" tabindex="-1">从 Webpack 到 Vite <a class="header-anchor" href="#从-webpack-到-vite" aria-label="Permalink to &quot;从 Webpack 到 Vite&quot;">​</a></h1><h2 id="webpack" tabindex="-1">Webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;Webpack&quot;">​</a></h2><p>开发环境使用 <code>webpack</code> 启动项目时，模块会在 <code>webpack</code> 中进行打包，最终打包成 <code>bundle</code>，随后返回一个开发环境路径</p><h3 id="这样有两个缺点" tabindex="-1">这样有两个缺点 <a class="header-anchor" href="#这样有两个缺点" aria-label="Permalink to &quot;这样有两个缺点&quot;">​</a></h3><ul><li>1.当前项目较大时，依赖的包和第三方会很多，这样打包的速度会非常慢（可以在 network 处观察请求数量印证）。</li><li>2.热替换十分繁琐，当改动一个模块后相关模块也需要重新打包，重新打包后发送到 <code>devServer</code> 服务器。</li></ul><p><img src="'+t+'" alt="webpack 原理图"></p><h2 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h2><p><code>Vite</code> 没有打包过程，直接启动开发服务器 <code>devServer</code>，它使用 <code>koa</code> 直接启动因此速度非常快</p><p>即便项目使用的包和第三方库很多，但由于 <code>Vite</code> 没有打包过程而是直接启动服务器，因此它还是会很快启动；</p><p>当访问页面时会直接返回 <code>index.html</code> 文件，而这个文件中入口 <code>js</code> 使用的是 <code>module</code> 的方式引入的，因此这个入口js不需要被编译；</p><p>在使用其他模块时，使用哪个编译哪个，编译后返回页面；</p><p>在编译 <code>.vue</code> 文件时，会将文件内容编译成纯 <code>js</code>，这得益于包：<code>@vue/compiler-sfc</code> 单文件组件编译器；</p><p>总结：</p><blockquote><p>vite 之所以快，是因为它没有打包的过程，只有编译，开发服务器在用到哪个模块后才会编译哪个模块</p></blockquote><p><img src="'+p+'" alt="Vite 原理图"></p><h2 id="vite-和-webpack-的对比" tabindex="-1">Vite 和 Webpack 的对比 <a class="header-anchor" href="#vite-和-webpack-的对比" aria-label="Permalink to &quot;Vite 和 Webpack 的对比&quot;">​</a></h2><p><code>webpack</code> 会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。</p><p>而 <code>vite</code> 是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。</p><p>由于现代浏览器本身就支持 <code>ES Module</code>，会自动向依赖的 <code>Module</code> 发出请求。<code>vite</code> 充分利用这一点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像 <code>webpack</code> 那样进行打包合并。</p><p>由于 <code>vite</code> 在启动时不需要打包，也就意味着不需要分析模块依赖、不需要编译，因此启动速度非常快。</p><p>当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂，模块越多，<code>vite</code> 的优势越明显。</p><p>在 <code>HMR（热替换）</code> 方面，当改动一个模块后，仅需要让浏览器重新请求该模块即可，不像 <code>webpack</code> 那样需要把该模块的相关依赖模块全部编译一次，效率更高。</p><p>当需要打包到生产环境时，<code>vite</code> 使用传统的 <code>rollup</code> 进行打包，因此，<code>vite</code> 的主要优势是在开发阶段。另外，由于vite利用的是 <code>ES Module</code> ，因此代码中不可以使用 <code>CommonJS</code>。</p>',23)]))}const v=c(i,[["render",r]]);export{u as __pageData,v as default};
