import{_ as o,c as r,a0 as a,j as e,G as t,w as n,a as s,B as d,o as p}from"./chunks/framework.Db5sgsAJ.js";const f="/assets/1._rsPGxIq.png",u="/assets/2.CAkHOl_3.png",c="/assets/3.CBS2tf_U.png",h="/assets/4.DMh3IRPJ.png",x="/assets/5.Bw_XVIbV.png",C=JSON.parse('{"title":"Flex 布局","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"css/css3-flex.md","filePath":"css/css3-flex.md"}'),k={name:"css/css3-flex.md"},g={tabindex:"0"};function m(b,l,E,w,y,F){const i=d("nobr");return p(),r("div",null,[l[19]||(l[19]=a(`<h1 id="flex-布局" tabindex="-1">Flex 布局 <a class="header-anchor" href="#flex-布局" aria-label="Permalink to &quot;Flex 布局&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noreferrer">参考</a></p><p>Flex 布局，即 弹性布局，是 CSS3 中新增的布局方式，它允许开发者以一种更简洁的方式来定义元素在容器中的排列方式，从而实现更灵活的布局。</p><p>通过 <code>display: flex;</code> 或 <code>display: inline-flex</code> 来开启 Flex 布局。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inline-flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>设置为 Flex 布局后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 属性将失效。</p></div><h3 id="flex-与-inline-flex的区别" tabindex="-1">flex 与 inline-flex的区别 <a class="header-anchor" href="#flex-与-inline-flex的区别" aria-label="Permalink to &quot;flex 与 inline-flex的区别&quot;">​</a></h3><p><strong>display: flex 的特点</strong></p><ul><li>块级弹性盒子：设置 <code>display: flex;</code>时，他会是一个带着块级特点的弹性盒子容器。</li><li>占据空间：因为拥有块级特点，因此它会占据芙蓉区的整个宽度，并且会独占一行。</li></ul><p><strong>display: inline-flex 的特点</strong></p><ul><li>行级弹性盒子：设置 <code>display: inline-flex;</code>时，他会是一个带有行级特点的弹性盒子容器。</li><li>占据空间：因为拥有行级的特点，因此他只占据所需的最小空间，且不会独占一行，可以与其他行级元素在一行显示。</li></ul><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p><code>flex</code> 布局容器拥有两根轴，默认<strong>水平方向</strong>为<code>主轴</code>、<strong>垂直方向</strong>为<code>交叉轴</code>。</p><p>默认情况下，容器内的元素，无论是行级元素还是块级元素都会按照主轴方向排列开来。</p><h2 id="容器的样式" tabindex="-1">容器的样式 <a class="header-anchor" href="#容器的样式" aria-label="Permalink to &quot;容器的样式&quot;">​</a></h2>`,16)),e("table",g,[l[18]||(l[18]=e("thead",null,[e("tr",null,[e("th",null,"名称"),e("th",null,"描述"),e("th",null,"可用值")])],-1)),e("tbody",null,[e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[0]||(l[0]=[s(" flex-direction ")])),_:1})]),l[1]||(l[1]=e("td",null,"设置主轴方向",-1)),l[2]||(l[2]=e("td",null,"row / row-reverse / column / column-reverse",-1))]),e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[3]||(l[3]=[s(" flex-wrap ")])),_:1})]),l[4]||(l[4]=e("td",null,"设置元素换行方式",-1)),l[5]||(l[5]=e("td",null,"nowrap / wrap / wrap-reverse",-1))]),e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[6]||(l[6]=[s(" flex-flow ")])),_:1})]),l[7]||(l[7]=e("td",null,[s("同时设置 "),e("code",null,"flex-direction"),s(" 和 "),e("code",null,"flex-wrap")],-1)),l[8]||(l[8]=e("td",null,"flex-flow: row wrap;",-1))]),e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[9]||(l[9]=[s(" justify-content ")])),_:1})]),l[10]||(l[10]=e("td",null,"设置主轴对齐方式",-1)),l[11]||(l[11]=e("td",null,"flex-start / flex-end / center / space-between / space-around",-1))]),e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[12]||(l[12]=[s(" align-items ")])),_:1})]),l[13]||(l[13]=e("td",null,"设置交叉轴对齐方式",-1)),l[14]||(l[14]=e("td",null,"flex-start / flex-end / center / baseline / stretch",-1))]),e("tr",null,[e("td",null,[t(i,null,{default:n(()=>l[15]||(l[15]=[s(" align-content ")])),_:1})]),l[16]||(l[16]=e("td",null,"设置多根轴线对齐方式",-1)),l[17]||(l[17]=e("td",null,"flex-start / flex-end / center / space-between / space-around / stretch",-1))])])]),l[20]||(l[20]=a('<h3 id="flex-direction-主轴方向" tabindex="-1">flex-direction（主轴方向） <a class="header-anchor" href="#flex-direction-主轴方向" aria-label="Permalink to &quot;flex-direction（主轴方向）&quot;">​</a></h3><p><code>flex-direction</code> 决定了主轴的方向。</p><ul><li><strong>row</strong>：主轴为水平方向，起点在左端。</li><li><strong>row-reverse</strong>：主轴为水平方向，起点在右端。</li><li><strong>column</strong>：主轴为垂直方向，起点在上沿。</li><li><strong>column-reverse</strong>：主轴为垂直方向，起点在下沿。</li></ul><p><img src="'+f+'" alt="flex-direction"></p><h3 id="flex-wrap-换行" tabindex="-1">flex-wrap（换行） <a class="header-anchor" href="#flex-wrap-换行" aria-label="Permalink to &quot;flex-wrap（换行）&quot;">​</a></h3><p><code>flex-wrap</code> 决定如何换行。正常情况下在容器尺寸不足时，元素会换行并继续按照主轴方向排列。</p><p><code>Flex 布局</code>中提供了多种灵活的换行方式</p><ul><li><strong>nowrap</strong>：（默认）不换行，元素会溢出容器。 <img src="'+u+'" alt="nowrap"></li><li><strong>wrap</strong>：正常换行。 <img src="'+c+'" alt="wrap"></li><li><strong>wrap-reverse</strong>：换行，但换行方向相反。 <img src="'+h+`" alt="wrap-reverse"></li></ul><h3 id="flex-flow-主轴方向-换行" tabindex="-1">flex-flow（主轴方向 换行） <a class="header-anchor" href="#flex-flow-主轴方向-换行" aria-label="Permalink to &quot;flex-flow（主轴方向 换行）&quot;">​</a></h3><p><code>flex-flow</code> 是 <code>flex-direction</code> 和 <code>flex-wrap</code> 的结合，默认值为 <code>row nowrap</code>。</p><p>他的参数有两个，第一个用于设置 <code>flex-direction</code>，第二个用于设置 <code>flex-wrap</code>。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  flex-flow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="justify-content-主轴对其方式" tabindex="-1">justify-content（主轴对其方式） <a class="header-anchor" href="#justify-content-主轴对其方式" aria-label="Permalink to &quot;justify-content（主轴对其方式）&quot;">​</a></h3><p><code>justify-content</code> 属性决定主轴上的对齐方式。</p><p>注意是主轴方向的对齐方式，因为 <code>flex 布局</code> 可以使用 <code>flex-direction</code> 来改变主轴，因此主轴不是一直都是水平方向。</p><ul><li>flex-start：（默认）左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>spance-between：两队对其，项目之间间隔相等</li><li>spance-around：每个项目两侧相等，因此项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="`+x+'" alt="justify-content"></p><h3 id="align-items-交叉轴对齐方式" tabindex="-1">align-items（交叉轴对齐方式） <a class="header-anchor" href="#align-items-交叉轴对齐方式" aria-label="Permalink to &quot;align-items（交叉轴对齐方式）&quot;">​</a></h3><p><code>align-items</code> 属性决定交叉轴上的对齐方式。</p><ul><li>flex-start</li><li>flex-end</li><li>center</li><li>baseline</li><li>stretch</li></ul>',20))])}const q=o(k,[["render",m]]);export{C as __pageData,q as default};
