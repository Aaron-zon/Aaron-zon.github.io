import{ax as e,A as t,aQ as l,z as i}from"./chunks/framework.BWRXlwpK.js";const p=JSON.parse('{"title":"浏览器渲染过程","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"js/js-render-process.md","filePath":"js/js-render-process.md"}'),r={name:"js/js-render-process.md"};function s(o,a,d,h,n,c){return i(),t("div",null,a[0]||(a[0]=[l('<h1 id="浏览器渲染过程" tabindex="-1">浏览器渲染过程 <a class="header-anchor" href="#浏览器渲染过程" aria-label="Permalink to &quot;浏览器渲染过程&quot;">​</a></h1><p>浏览器在下载完页面的组件（HTML、CSS、JS、图片等）后，会进行渲染。</p><h2 id="渲染步骤" tabindex="-1">渲染步骤 <a class="header-anchor" href="#渲染步骤" aria-label="Permalink to &quot;渲染步骤&quot;">​</a></h2><h3 id="_1-解析-html-生成-dom-tree" tabindex="-1">1.解析 HTML，生成 DOM Tree <a class="header-anchor" href="#_1-解析-html-生成-dom-tree" aria-label="Permalink to &quot;1.解析 HTML，生成 DOM Tree&quot;">​</a></h3><ul><li>浏览器受到 HTML 字节流</li><li>自上而下解析 HTML</li><li>遇到标签就创建 DOM 节点</li><li>最终生成 DOM 树</li></ul><h3 id="_2-解析-css-生成-cssom-tree" tabindex="-1">2.解析 CSS，生成 CSSOM Tree <a class="header-anchor" href="#_2-解析-css-生成-cssom-tree" aria-label="Permalink to &quot;2.解析 CSS，生成 CSSOM Tree&quot;">​</a></h3><ul><li>遇到 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code></li><li>下载 CSS</li><li>解析 CSS 规则</li><li>生成 CSSOM（CSS Object Model）</li></ul><h3 id="_3-生成-render-tree" tabindex="-1">3.生成 Render Tree <a class="header-anchor" href="#_3-生成-render-tree" aria-label="Permalink to &quot;3.生成 Render Tree&quot;">​</a></h3><p>把 DOM Tree 和 CSSOM Tree 合并，生成 Render Tree</p><h3 id="_4-layout-回流-布局" tabindex="-1">4.Layout（回流/布局） <a class="header-anchor" href="#_4-layout-回流-布局" aria-label="Permalink to &quot;4.Layout（回流/布局）&quot;">​</a></h3><blockquote><p>计算每个元素的位置和尺寸</p></blockquote><p>此阶段消耗cpu性能</p><h3 id="_5-paint-重绘" tabindex="-1">5. Paint（重绘） <a class="header-anchor" href="#_5-paint-重绘" aria-label="Permalink to &quot;5. Paint（重绘）&quot;">​</a></h3><blockquote><p>把元素绘制到屏幕上</p></blockquote><p>绘制包括：</p><ul><li>背景</li><li>颜色</li><li>边框</li><li>文字</li><li>阴影</li></ul><p>📌 只影响外观，不影响布局</p><h3 id="_6-composite-合成" tabindex="-1">6.Composite（合成） <a class="header-anchor" href="#_6-composite-合成" aria-label="Permalink to &quot;6.Composite（合成）&quot;">​</a></h3><ul><li>把不同图层，合成到屏幕上。</li></ul><h2 id="js-在渲染过程中的角色" tabindex="-1">JS 在渲染过程中的角色 <a class="header-anchor" href="#js-在渲染过程中的角色" aria-label="Permalink to &quot;JS 在渲染过程中的角色&quot;">​</a></h2><h3 id="_1-js-会阻塞dom解析" tabindex="-1">1.JS 会阻塞DOM解析 <a class="header-anchor" href="#_1-js-会阻塞dom解析" aria-label="Permalink to &quot;1.JS 会阻塞DOM解析&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ul><li>HTML 解析暂停</li><li>下载JS</li><li>执行JS</li><li>再继续解析</li></ul><h3 id="_2-async-和-defer-的区别" tabindex="-1">2.async 和 defer 的区别 <a class="header-anchor" href="#_2-async-和-defer-的区别" aria-label="Permalink to &quot;2.async 和 defer 的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>属性</th><th>下载</th><th>执行</th><th>是否阻塞 DOM</th></tr></thead><tbody><tr><td>普通 script</td><td>阻塞</td><td>立即</td><td>是</td></tr><tr><td>async</td><td>异步</td><td>下载完立刻</td><td>不一定</td></tr><tr><td>defer</td><td>异步</td><td>DOM 完成后</td><td>否</td></tr></tbody></table><h2 id="回流-reflow-和-重绘-repaint" tabindex="-1">回流（Reflow）和 重绘（Repaint） <a class="header-anchor" href="#回流-reflow-和-重绘-repaint" aria-label="Permalink to &quot;回流（Reflow）和 重绘（Repaint）&quot;">​</a></h2><p>⚠️ <strong>回流一定导致重绘，但重绘不一定回流</strong></p><h3 id="回流-layout" tabindex="-1">回流（Layout） <a class="header-anchor" href="#回流-layout" aria-label="Permalink to &quot;回流（Layout）&quot;">​</a></h3><p>触发条件：</p><ul><li>尺寸改变</li><li>位置改变</li><li>添加 / 删除 DOM</li><li>改变字体大小</li></ul><p>👉 <strong>开销大</strong></p><h3 id="重绘-paint" tabindex="-1">重绘（Paint） <a class="header-anchor" href="#重绘-paint" aria-label="Permalink to &quot;重绘（Paint）&quot;">​</a></h3><p>触发条件：</p><ul><li>颜色改变</li><li>背景改变</li><li>阴影改变</li></ul><p>👉 <strong>开销小于回流</strong></p><h2 id="性能优化的手段" tabindex="-1">性能优化的手段 <a class="header-anchor" href="#性能优化的手段" aria-label="Permalink to &quot;性能优化的手段&quot;">​</a></h2><h3 id="_1-减少回流" tabindex="-1">1.减少回流 <a class="header-anchor" href="#_1-减少回流" aria-label="Permalink to &quot;1.减少回流&quot;">​</a></h3><p>因为每次回流都很耗性能，因此可以尽量减少回流来做性能优化，具体方式：</p><ul><li>批量修改DOM，即一次性改完，让浏览器只回流一次。例如： <ul><li>1.做table行数据插入时，可以将所有要插入的内容放到字符串变量中，最后一次插入，而不是逐行插入</li><li>2.做更改元素样式时，不使用style.xxx，因为每次都有可能触发重绘，改为style.cssText一次性设置，或使用class</li></ul></li><li>使用 class 代替逐条 style</li><li>使用 transform 替代 top/left</li></ul><h3 id="_2-减少-css-阻塞" tabindex="-1">2.减少 CSS 阻塞 <a class="header-anchor" href="#_2-减少-css-阻塞" aria-label="Permalink to &quot;2.减少 CSS 阻塞&quot;">​</a></h3><ul><li>CSS放在 <code>&lt;head&gt;</code></li><li>精简 CSS</li><li>合理拆分 CSS</li></ul><h3 id="_3-js优化" tabindex="-1">3.JS优化 <a class="header-anchor" href="#_3-js优化" aria-label="Permalink to &quot;3.JS优化&quot;">​</a></h3><ul><li>使用 <code>defer</code></li><li>减少同步JS</li><li>避免频繁读取layout信息（如：offsetHeight），因为读取lyout信息会强制浏览器回流，频繁读取就会导致大量‘强制回流’ <ul><li>此外，如果你需要强制回流的话读取layout信息也是一个办法</li></ul></li></ul>',43)]))}const b=e(r,[["render",s]]);export{p as __pageData,b as default};
