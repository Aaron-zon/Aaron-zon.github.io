import{_ as r,c as o,a0 as a,j as e,G as i,w as t,a as s,B as d,o as p}from"./chunks/framework.Db5sgsAJ.js";const u="/assets/1._rsPGxIq.png",y=JSON.parse('{"title":"Flex 布局","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"css/css3-flex.md","filePath":"css/css3-flex.md"}'),f={name:"css/css3-flex.md"},x={tabindex:"0"};function h(k,l,g,c,b,m){const n=d("nobr");return p(),o("div",null,[l[19]||(l[19]=a(`<h1 id="flex-布局" tabindex="-1">Flex 布局 <a class="header-anchor" href="#flex-布局" aria-label="Permalink to &quot;Flex 布局&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noreferrer">参考</a></p><p>Flex 布局，即 弹性布局，是 CSS3 中新增的布局方式，它允许开发者以一种更简洁的方式来定义元素在容器中的排列方式，从而实现更灵活的布局。</p><p>通过 <code>display: flex;</code> 或 <code>display: inline-flex</code> 来开启 Flex 布局。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.box2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">inline-flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>设置为 Flex 布局后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 属性将失效。</p></div><h3 id="flex-与-inline-flex的区别" tabindex="-1">flex 与 inline-flex的区别 <a class="header-anchor" href="#flex-与-inline-flex的区别" aria-label="Permalink to &quot;flex 与 inline-flex的区别&quot;">​</a></h3><p><strong>display: flex 的特点</strong></p><ul><li>块级弹性盒子：设置 <code>display: flex;</code>时，他会是一个带着块级特点的弹性盒子容器。</li><li>占据空间：因为拥有块级特点，因此它会占据芙蓉区的整个宽度，并且会独占一行。</li></ul><p><strong>display: inline-flex 的特点</strong></p><ul><li>行级弹性盒子：设置 <code>display: inline-flex;</code>时，他会是一个带有行级特点的弹性盒子容器。</li><li>占据空间：因为拥有行级的特点，因此他只占据所需的最小空间，且不会独占一行，可以与其他行级元素在一行显示。</li></ul><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h2><p><code>flex</code> 布局容器拥有两根轴，默认<strong>水平方向</strong>为<code>主轴</code>、<strong>垂直方向</strong>为<code>交叉轴</code>。</p><p>默认情况下，容器内的元素，无论是行级元素还是块级元素都会按照主轴方向排列开来。</p><h2 id="容器的样式" tabindex="-1">容器的样式 <a class="header-anchor" href="#容器的样式" aria-label="Permalink to &quot;容器的样式&quot;">​</a></h2>`,16)),e("table",x,[l[18]||(l[18]=e("thead",null,[e("tr",null,[e("th",null,"名称"),e("th",null,"描述"),e("th",null,"可用值")])],-1)),e("tbody",null,[e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[0]||(l[0]=[s(" flex-direction ")])),_:1})]),l[1]||(l[1]=e("td",null,"设置主轴方向",-1)),l[2]||(l[2]=e("td",null,"row / row-reverse / column / column-reverse",-1))]),e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[3]||(l[3]=[s(" flex-wrap ")])),_:1})]),l[4]||(l[4]=e("td",null,"设置元素换行方式",-1)),l[5]||(l[5]=e("td",null,"nowrap / wrap / wrap-reverse",-1))]),e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[6]||(l[6]=[s(" flex-flow ")])),_:1})]),l[7]||(l[7]=e("td",null,[s("同时设置 "),e("code",null,"flex-direction"),s(" 和 "),e("code",null,"flex-wrap")],-1)),l[8]||(l[8]=e("td",null,"flex-flow: row wrap;",-1))]),e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[9]||(l[9]=[s(" justify-content ")])),_:1})]),l[10]||(l[10]=e("td",null,"设置主轴对齐方式",-1)),l[11]||(l[11]=e("td",null,"flex-start / flex-end / center / space-between / space-around",-1))]),e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[12]||(l[12]=[s(" align-items ")])),_:1})]),l[13]||(l[13]=e("td",null,"设置交叉轴对齐方式",-1)),l[14]||(l[14]=e("td",null,"flex-start / flex-end / center / baseline / stretch",-1))]),e("tr",null,[e("td",null,[i(n,null,{default:t(()=>l[15]||(l[15]=[s(" align-content ")])),_:1})]),l[16]||(l[16]=e("td",null,"设置多根轴线对齐方式",-1)),l[17]||(l[17]=e("td",null,"flex-start / flex-end / center / space-between / space-around / stretch",-1))])])]),l[20]||(l[20]=a('<h3 id="flex-direction" tabindex="-1">flex-direction <a class="header-anchor" href="#flex-direction" aria-label="Permalink to &quot;flex-direction&quot;">​</a></h3><p><code>flex-direction</code> 决定了主轴的方向。</p><ul><li><strong>row</strong>：主轴为水平方向，起点在左端。</li><li><strong>row-reverse</strong>：主轴为水平方向，起点在右端。</li><li><strong>column</strong>：主轴为垂直方向，起点在上沿。</li><li><strong>column-reverse</strong>：主轴为垂直方向，起点在下沿。</li></ul><p><img src="'+u+'" alt="flex-direction"></p><h3 id="flex-wrap" tabindex="-1">flex-wrap <a class="header-anchor" href="#flex-wrap" aria-label="Permalink to &quot;flex-wrap&quot;">​</a></h3><p><code>flex-wrap</code> 决定如何换行。正常情况下在容器尺寸不足时，元素会换行并继续按照主轴方向排列。</p><p><code>Flex 布局</code>中提供了多种灵活的换行方式</p><ul><li>nowrap：不换行，元素会溢出容器。</li><li>wrap：正常换行。</li><li>wrap-reverse：换行，但换行方向相反。</li></ul>',8))])}const w=r(f,[["render",h]]);export{y as __pageData,w as default};
