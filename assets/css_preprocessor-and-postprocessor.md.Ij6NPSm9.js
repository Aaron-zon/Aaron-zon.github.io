import{_ as o,c as r,a2 as e,o as l}from"./chunks/framework.BLTIpkzl.js";const u=JSON.parse('{"title":"CSS 预处理器 / 后处理器 / 原子化","description":"","frontmatter":{},"headers":[],"relativePath":"css/preprocessor-and-postprocessor.md","filePath":"css/preprocessor-and-postprocessor.md"}'),t={name:"css/preprocessor-and-postprocessor.md"};function p(i,s,a,c,S,n){return l(),r("div",null,s[0]||(s[0]=[e('<h1 id="css-预处理器-后处理器-原子化" tabindex="-1">CSS 预处理器 / 后处理器 / 原子化 <a class="header-anchor" href="#css-预处理器-后处理器-原子化" aria-label="Permalink to &quot;CSS 预处理器 / 后处理器 / 原子化&quot;">​</a></h1><p>CSS 预处理器和后处理器是用于增强 CSS 功能的工具，它们分别在编译时（预处理器）和生成后的 CSS 文件上（后处理器）进行操作。</p><h2 id="css-预处理器-pre-processor" tabindex="-1">CSS 预处理器 pre-processor <a class="header-anchor" href="#css-预处理器-pre-processor" aria-label="Permalink to &quot;CSS 预处理器 pre-processor&quot;">​</a></h2><p>CSS 预处理器是在编写样式表时使用的语言扩展，它们提供了编程特性如变量、嵌套规则、混合宏（mixins）、函数等，使得编写和维护 CSS 更加容易。预处理器编写的代码需要经过编译步骤才能转换为标准的 CSS 代码。</p><p><strong>常见的有：</strong></p><ul><li>Sass / Scss</li><li>Less</li></ul><p><strong>使用场景和特点</strong></p><ul><li>模块化开发：可以将样式拆分成多个文件，便于管理和复用</li><li>提高可读性：嵌套的结构可以让代码更直观</li><li>代码宠用：利用 mixin 和 函数 减少重复代码</li><li>定制主体：可以通过定义、使用变量来快速切换主题</li></ul><h2 id="css-后处理器-post-processor" tabindex="-1">CSS 后处理器 post-processor <a class="header-anchor" href="#css-后处理器-post-processor" aria-label="Permalink to &quot;CSS 后处理器 post-processor&quot;">​</a></h2><p>CSS 后处理器是在 CSS 文件已经生成之后对其进行处理的工具。进行添加浏览器前缀、优化代码、检查错误或者根据特定规则修改样式。</p><p><strong>常见的有：</strong></p><ul><li>PostCSS</li></ul><h2 id="css-原子化" tabindex="-1">CSS 原子化 <a class="header-anchor" href="#css-原子化" aria-label="Permalink to &quot;CSS 原子化&quot;">​</a></h2><p>CSS 原子化是一种编写、管理 CSS样式的方式，和传统的 CSS 有些不同，它就像是在行级写 style 一样，每一个 class 代表着一个样式或多个紧密相关的样式，它将样式拆分到最小、不可再分 —— 即 <code>原子</code>。</p><p>每个原子类只负责一个单一的样式，无需编写传统的具合了多种样式的 CSS 规则。</p><p>但是我不是很喜欢这种编写方式，在一些项目中确实可以提高效率，但对我来说在阅读代码时太乱了，很像在行级写 style，在 HTML 中过于臃肿。</p><p>而且尽管有好用的预设，但是还是需要一定的学习成本。而脱离写好的预设又需要大量的时间进行预设。</p><p><strong>核心理念</strong></p><ul><li><strong>单一职责原则：</strong><ul><li>每个 CSS 类进定义一个样式属性或少量紧密相关的属性</li><li>例如 <code>p-4</code> 只设置 <code>padding: 1rem;</code>，<code>text-center</code> 只设置 <code>text-align: center;</code></li></ul></li><li><strong>按需使用</strong><ul><li>只有在 HTML 中实际使用的类才会被包含在最终的 CSS 文件中，避免了未使用的样式规则占用空间。</li><li>这种方式减少了 CSS 文件的大小，提升了页面加载速度。（我没试过测试速度）</li></ul></li><li><strong>快速开发与迭代：</strong><ul><li>开发者可以直接在 HTML 或模板文件中应用现成的原子类，而不需要频繁切换到 CSS 文件进行修改。</li><li>这样可以加速开发流程，并且使得样式调整更加直观。 。。。（还有一些我没体验到的不列举）</li></ul></li></ul><p>在开发文档一类静态网站时确实会快一些，但我想我不会在一般项目中使用这种写法。</p><p><strong>常用</strong></p><ul><li>Tailwind CSS</li><li>UnoCss</li></ul><p>两个在官方都没有中文文档，这也是我不常用的原因。</p>',23)]))}const C=o(t,[["render",p]]);export{u as __pageData,C as default};
