import{_ as o,c as a,a0 as c,o as t}from"./chunks/framework.UCJAoCzn.js";const h=JSON.parse('{"title":"API和数据响应式的变化","description":"","frontmatter":{},"headers":[],"relativePath":"vue3/change-api-and-reactivity.md","filePath":"vue3/change-api-and-reactivity.md"}'),d={name:"vue3/change-api-and-reactivity.md"};function u(r,e,p,i,n,l){return t(),a("div",null,e[0]||(e[0]=[c('<h1 id="api和数据响应式的变化" tabindex="-1">API和数据响应式的变化 <a class="header-anchor" href="#api和数据响应式的变化" aria-label="Permalink to &quot;API和数据响应式的变化&quot;">​</a></h1><h2 id="为什么去掉了-vue-构造函数" tabindex="-1">为什么去掉了 Vue 构造函数? <a class="header-anchor" href="#为什么去掉了-vue-构造函数" aria-label="Permalink to &quot;为什么去掉了 Vue 构造函数?&quot;">​</a></h2><p>在过去，如果页面上遇到一个页面创建多个 <code>Vue</code> 实例时可能会出现一些问题.</p><p>当对一个实例进行 Vue.use()、Vue.mixin()、Vue.component() 配置时，影响的将时所有的Vue实例。</p><p>在 <code>Vue3</code> 中，去掉了<code>Vue构造函数</code>，转而使用 <code>createApp</code> 函数来创建应用实例，把全局操作放到了 <code>Vue实例</code> 中，这样可以使实例之间互不影响。</p><p>整理后的回答：</p><blockquote><p>1.调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同应用</p></blockquote><blockquote><p>2.vue2的构造函数继承太多功能了，不利于tree shaking，vue3把这些功能用普通函数到处，能够充分tree shaking优化打包体积</p></blockquote><blockquote><p>3.vue2没有把组件实例和vue应用两个概念区分开，在vue2中，通过new Vue创建对象，即是一个vue应用，同时又是一个特殊的vue组件。在vue3中，把两个概念区分开来，通过createApp创建的对象，是一个vue应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件</p></blockquote><h2 id="vue3-响应式" tabindex="-1">Vue3 响应式 <a class="header-anchor" href="#vue3-响应式" aria-label="Permalink to &quot;Vue3 响应式&quot;">​</a></h2><p><code>Vue3</code> 不再使用 <code>Object.defineProperty</code> 的方式定义完成数据响应式，而是使用 <code>Proxy</code>。</p><p>除了 <code>Proxy</code> 本身效率比 <code>Object.defineProperty</code> 更高之外，由于不必递归所有属性，而是直接得到一个 <code>Proxy</code>。所以在 <code>Vue3</code> 中，对数据的访问是同台的，当访问某个属性的时候，再动态的获取和设置，这就极大的提升了在组建初始阶段的效率。</p><p>同时，由于 <code>Proxy</code> 可以监控到成员的新增和删除，因此，在 <code>Vue3</code> 中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在 <code>Vue2</code> 中是难以做到的。</p>',13)]))}const v=o(d,[["render",u]]);export{h as __pageData,v as default};
